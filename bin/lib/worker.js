// Generated by CoffeeScript 1.12.2
(function() {
  var BURY_PRIORITY, DEFAULT_TTR, EventEmitter, RESERVE_WAIT_TIME, RETRY_DELAY, RETRY_PRIORITY, exports, fivebeans, rest, util;

  fivebeans = require('fivebeans');

  rest = require('restler');

  util = require('util');

  EventEmitter = require('events').EventEmitter;

  RETRY_PRIORITY = 11;

  RETRY_DELAY = 5;

  RESERVE_WAIT_TIME = 2.5;

  BURY_PRIORITY = 1024;

  DEFAULT_TTR = 300;

  exports = {};

  exports.buildWorker = function(opts) {
    var beanstalkHost, beanstalkPort, client, clientClosed, clientConnected, clientErrored, clientTimeout, connected, eventsTube, finishJob, initClients, insertJobIntoBeanstalk, keenAPIKey, keenProjectID, logger, maxRetries, mixpanelProjectToken, processJob, processKeenStatsJob, processMixpanelJob, processRestlerJob, processSlackJob, ref, ref1, ref10, ref11, ref12, ref13, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, runNextJob, self, shutdownClient, shutdownRequested, slackChannel, slackIconURL, slackUsername, slackWebAPIToken, startingUpPhase, watchTubes, workerId, writeClient, writeClientClosed, writeClientConnected, writeClientErrored, writeClientReady;
    workerId = (function() {
      if ((ref = opts.workerId) != null) {
        return ref;
      } else {
        throw new Error('workerId is required');
      }
    })();
    beanstalkHost = (function() {
      if ((ref1 = opts.beanstalkHost) != null) {
        return ref1;
      } else {
        throw new Error('beanstalkHost is required');
      }
    })();
    beanstalkPort = (function() {
      if ((ref2 = opts.beanstalkPort) != null) {
        return ref2;
      } else {
        throw new Error('beanstalkPort is required');
      }
    })();
    eventsTube = (function() {
      if ((ref3 = opts.eventsTube) != null) {
        return ref3;
      } else {
        throw new Error('eventsTube is required');
      }
    })();
    clientTimeout = (function() {
      if ((ref4 = opts.clientTimeout) != null) {
        return ref4;
      } else {
        throw new Error('clientTimeout is required');
      }
    })();
    maxRetries = (function() {
      if ((ref5 = opts.maxRetries) != null) {
        return ref5;
      } else {
        throw new Error('maxRetries is required');
      }
    })();
    logger = (function() {
      if ((ref6 = opts.logger) != null) {
        return ref6;
      } else {
        throw new Error('logger is required');
      }
    })();
    keenProjectID = (function() {
      if ((ref7 = opts.keenProjectID) != null) {
        return ref7;
      } else {
        throw new Error('keenProjectID is required');
      }
    })();
    keenAPIKey = (function() {
      if ((ref8 = opts.keenAPIKey) != null) {
        return ref8;
      } else {
        throw new Error('keenAPIKey is required');
      }
    })();
    mixpanelProjectToken = (function() {
      if ((ref9 = opts.mixpanelProjectToken) != null) {
        return ref9;
      } else {
        throw new Error('mixpanelProjectToken is required');
      }
    })();
    slackWebAPIToken = (function() {
      if ((ref10 = opts.slackWebAPIToken) != null) {
        return ref10;
      } else {
        throw new Error('slackWebAPIToken is required');
      }
    })();
    slackUsername = (function() {
      if ((ref11 = opts.slackUsername) != null) {
        return ref11;
      } else {
        throw new Error('slackUsername is required');
      }
    })();
    slackChannel = (function() {
      if ((ref12 = opts.slackChannel) != null) {
        return ref12;
      } else {
        throw new Error('slackChannel is required');
      }
    })();
    slackIconURL = (function() {
      if ((ref13 = opts.slackIconURL) != null) {
        return ref13;
      } else {
        throw new Error('slackIconURL is required');
      }
    })();
    self = new EventEmitter();
    clientConnected = function() {
      var connected;
      logger.silly("worker " + workerId + " connected");
      connected = true;
      watchTubes();
    };
    clientErrored = function(err) {
      logger.warn("client error", {
        name: 'client.error',
        error: err,
        workerId: workerId
      });
      self.emit('error.client', err);
      if (!shutdownRequested) {
        shutdownClient();
      }
    };
    clientClosed = function() {
      var connected;
      connected = false;
      self.running = false;
      self.busy = false;
      logger.silly("client closed", {
        workerId: workerId
      });
      self.emit('closed', workerId);
    };
    shutdownClient = function() {
      var connected;
      client.end();
      writeClient.end();
      connected = false;
      self.running = false;
      self.busy = false;
    };
    watchTubes = function() {
      return client.watch(eventsTube, function(err, numwatched) {
        if (err) {
          logger.warn("error watching eventsTube", {
            name: 'eventsTubeWatch.error',
            error: err,
            eventsTube: eventsTube,
            workerId: workerId
          });
          shutdownClient();
          return;
        }
        self.emit('next');
      });
    };
    runNextJob = function() {
      if (shutdownRequested) {
        shutdownClient();
        return;
      }
      return client.reserve_with_timeout(RESERVE_WAIT_TIME, function(err, jobId, payload) {
        var e, jobData;
        if (err) {
          if (err === 'TIMED_OUT') {
            self.emit('loop');
            self.emit('next');
            return;
          }
          logger.warn("client error", {
            name: 'client.error',
            error: err,
            workerId: workerId
          });
          shutdownClient();
          return;
        }
        try {
          logger.silly("running job " + jobId);
          jobData = JSON.parse(payload);
          self.busy = true;
          processJob(jobId, jobData, function(completed) {
            client.destroy(jobId, function(err) {
              self.busy = false;
              if (err) {
                logger.warn("destroy error", {
                  name: 'error.destroy',
                  error: err,
                  jobId: jobId,
                  workerId: workerId
                });
                shutdownClient();
                return;
              }
              self.emit('next');
            });
          });
        } catch (error) {
          e = error;
          self.busy = false;
          logger.warn("error.uncaught " + e, {
            name: 'error.uncaught',
            error: '' + e,
            jobId: jobId,
            workerId: workerId
          });
          self.emit('error.job', e);
          shutdownClient();
        }
      });
    };
    processJob = function(jobId, jobData, callback) {
      var err, jobHandler, ref14, ref15, success;
      success = false;
      if (((ref14 = jobData.meta) != null ? ref14.attempt : void 0) == null) {
        logger.warn("error.badJob", {
          name: 'error.badJob',
          jobData: JSON.stringify(jobData),
          jobId: jobId,
          workerId: workerId
        });
        callback(true);
        return;
      }
      try {
        logger.info("begin processing job", {
          name: 'job.begin',
          jobId: jobId,
          notificationId: jobData.meta.id,
          attempt: jobData.meta.attempt,
          maxRetries: maxRetries,
          jobType: jobData.meta.jobType
        });
        if (jobData.meta.jobType === 'mixpanel') {
          jobHandler = processMixpanelJob;
        } else if (jobData.meta.jobType === 'keen') {
          jobHandler = processKeenStatsJob;
        } else if (jobData.meta.jobType === 'slack') {
          jobHandler = processSlackJob;
        } else {
          finishJob(false, 'Unknown jobtype: ' + jobData.meta.jobType, jobData, jobId, callback);
          return;
        }
        jobHandler(jobData, jobId, callback);
      } catch (error) {
        err = error;
        console.error(err);
        logger.error("Unexpected error", {
          name: 'job.errorUnexpected',
          jobId: jobId,
          notificationId: ((ref15 = jobData.meta) != null ? ref15.id : void 0) != null,
          error: err.message,
          href: href
        });
        finishJob(false, "Unexpected error: " + err, jobData, jobId, callback);
        return;
      }
    };
    finishJob = function(success, errString, jobData, jobId, callback) {
      var _logData, finished;
      finished = false;
      if (success) {
        finished = true;
      } else {
        if (jobData.meta.attempt >= maxRetries) {
          logger.warn("Job giving up after attempt " + jobData.meta.attempt, {
            name: 'job.failed',
            jobId: jobId,
            notificationId: jobData.meta.id,
            attempts: jobData.meta.attempt
          });
          finished = true;
        } else {
          logger.debug("Retrying job after error", {
            name: 'job.retry',
            jobId: jobId,
            notificationId: jobData.meta.id,
            attempts: jobData.meta.attempt,
            error: errString
          });
        }
      }
      if (finished) {
        _logData = {
          name: 'job.finished',
          jobId: jobId,
          notificationId: jobData.meta.id,
          href: jobData.meta.endpoint,
          totalAttempts: jobData.meta.attempt,
          success: success
        };
        if (errString) {
          _logData.error = errString;
        }
        logger.info("Job finished", _logData);
        callback(true);
      } else {
        insertJobIntoBeanstalk(eventsTube, jobData, RETRY_PRIORITY, RETRY_DELAY * jobData.meta.attempt, function(loadSuccess) {
          return callback(loadSuccess);
        });
      }
    };
    writeClientConnected = function() {
      var writeClientReady;
      writeClientReady = true;
    };
    writeClientErrored = function(err) {
      logger.warn("writeClient error", {
        name: 'error.writeClient',
        error: err,
        workerId: workerId
      });
      shutdownClient();
    };
    writeClientClosed = function() {
      var writeClientReady;
      writeClientReady = false;
      logger.silly("writeClient closed", {
        workerId: workerId
      });
      if (startingUpPhase) {
        self.emit('closed', workerId);
      }
    };
    insertJobIntoBeanstalk = function(queue, data, retry_priority, retry_delay, callback, attempts) {
      if (attempts == null) {
        attempts = 0;
      }
      writeClient.use(queue, function(err, tubename) {
        if (err) {
          logger.warn("error selecting queue", {
            name: 'error.writeClientWatch',
            error: err,
            queue: queue,
            workerId: workerId
          });
          callback(false);
          return;
        }
        if (tubename !== queue) {
          ++attempts;
          if (attempts > 3) {
            logger.warn("queue mismatch", {
              name: 'error.fatalQueueMismatch',
              attempts: attempts,
              tubename: tubename,
              queue: queue,
              workerId: workerId
            });
          } else {
            logger.warn("queue mismatch", {
              name: 'error.queueMismatch',
              attempts: attempts,
              tubename: tubename,
              queue: queue,
              workerId: workerId
            });
            setTimeout(function() {
              return insertJobIntoBeanstalk(queue, data, retry_priority, retry_delay, callback, attempts);
            }, attempts * 125);
          }
          return;
        }
        return writeClient.put(retry_priority, retry_delay, DEFAULT_TTR, JSON.stringify(data), function(err, jobId) {
          if (err) {
            logger.warn("error loading job", {
              name: 'loadJob.failed',
              queue: queue
            });
            callback(false);
            return;
          }
          callback(true);
        });
      });
    };
    processKeenStatsJob = function(jobData, jobId, callback) {
      var href, requestData;
      if (!keenAPIKey) {
        finishJob(true, 'No keenAPIKey defined', jobData, jobId, callback);
        return;
      }
      if (!keenProjectID) {
        finishJob(true, 'No keenProjectID defined', jobData, jobId, callback);
        return;
      }
      href = "https://api.keen.io/3.0/projects/" + keenProjectID + "/events/" + jobData.meta.collection + "?api_key=" + keenAPIKey;
      requestData = JSON.stringify(jobData.data);
      return processRestlerJob(jobData, jobId, href, true, requestData, callback);
    };
    processMixpanelJob = function(jobData, jobId, callback) {
      var href, mixpanelEvent, requestData;
      if (!mixpanelProjectToken) {
        finishJob(true, 'No mixpanelProjectToken defined', jobData, jobId, callback);
        return;
      }
      mixpanelEvent = {
        event: jobData.meta.collection,
        properties: jobData.data
      };
      mixpanelEvent.properties.token = mixpanelProjectToken;
      href = "http://api.mixpanel.com/track/";
      requestData = {
        data: new Buffer(JSON.stringify(mixpanelEvent)).toString('base64')
      };
      return processRestlerJob(jobData, jobId, href, false, requestData, callback);
    };
    processSlackJob = function(jobData, job, callback) {
      var href, k, ref14, requestData, v;
      if (!slackWebAPIToken) {
        finishJob(true, 'No slackWebAPIToken defined', jobData, job, callback);
        return;
      }
      requestData = {
        token: slackWebAPIToken,
        username: slackUsername,
        channel: slackChannel,
        icon_url: slackIconURL,
        text: ''
      };
      ref14 = jobData.data;
      for (k in ref14) {
        v = ref14[k];
        requestData[k] = v;
      }
      logger.silly("requestData", requestData);
      href = "https://slack.com/api/chat.postMessage";
      return processRestlerJob(jobData, job, href, false, requestData, callback);
    };
    processRestlerJob = function(jobData, jobId, href, isPost, requestData, callback) {
      var callFn, callParams, err, ref14, success;
      success = false;
      if (((ref14 = jobData.meta) != null ? ref14.attempt : void 0) == null) {
        jobData.meta.attempt = 0;
      }
      jobData.meta.attempt = jobData.meta.attempt + 1;
      try {
        logger.silly("begin processRestlerJob " + jobId + " (attempt " + jobData.meta.attempt + " of " + maxRetries + ", href " + href + ")");
        callParams = {
          headers: {
            'User-Agent': 'Tokenly Event Proxy'
          },
          timeout: clientTimeout
        };
        if (isPost) {
          callParams.headers['Content-Type'] = 'application/json';
          callFn = rest.post;
          callParams.data = requestData;
        } else {
          callFn = rest.get;
          callParams.query = requestData;
        }
        callFn(href, callParams).on('complete', function(data, response) {
          var msg, ref15, ref16;
          msg = '';
          if (response) {
            logger.silly("received HTTP response: " + (response != null ? (ref15 = response.statusCode) != null ? ref15.toString() : void 0 : void 0), {
              statusCode: response != null ? (ref16 = response.statusCode) != null ? ref16.toString() : void 0 : void 0
            });
          } else {
            logger.warn("received no HTTP response");
          }
          if ((response != null) && response.statusCode.toString().charAt(0) === '2') {
            success = true;
          } else {
            success = false;
            if (response != null) {
              msg = "ERROR: received HTTP response with code " + response.statusCode;
              logger.warn("HTTP error", {
                jobId: jobId,
                statusCode: response.statusCode
              });
            } else {
              if (data instanceof Error) {
                msg = "" + data;
              } else {
                msg = "ERROR: no HTTP response received";
              }
            }
          }
          finishJob(success, msg, jobData, jobId, callback);
        }).on('timeout', function(e) {
          logger.warn("Job timeout", {
            jobId: jobId
          });
          finishJob(false, "Timeout: " + e, jobData, jobId, callback);
        }).on('error', function(e) {});
      } catch (error) {
        err = error;
        logger.silly("[" + (new Date().toString()) + "] Caught ERROR:", err);
        logger.silly(err.stack);
        finishJob(false, "Unexpected error: " + err, jobData, jobId, callback);
        return;
      }
    };
    client = null;
    writeClient = null;
    writeClientReady = false;
    connected = false;
    shutdownRequested = false;
    self.running = false;
    self.busy = false;
    startingUpPhase = false;
    self.on('next', runNextJob);
    initClients = function() {
      client = new fivebeans.client(beanstalkHost, beanstalkPort);
      client.on('connect', clientConnected);
      client.on('error', clientErrored);
      client.on('close', clientClosed);
      writeClient = new fivebeans.client(beanstalkHost, beanstalkPort);
      writeClientReady = false;
      writeClient.on('connect', writeClientConnected);
      writeClient.on('connect', function() {
        startingUpPhase = false;
        client.connect();
      });
      writeClient.on('error', writeClientErrored);
      writeClient.on('close', writeClientClosed);
    };
    self.getId = function() {
      return workerId;
    };
    self.run = function() {
      logger.silly("launching worker " + workerId);
      client = null;
      writeClient = null;
      shutdownRequested = false;
      self.running = true;
      startingUpPhase = true;
      initClients();
      writeClient.connect();
    };
    self.stop = function() {
      shutdownRequested = true;
    };
    return self;
  };

  module.exports = exports;

}).call(this);
